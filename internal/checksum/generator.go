package checksum

import (
	"bufio"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"hash"
	"io"
	"os"
	"sort"
	"strings"
	"sync"
)

// ChecksumGenerator calculates and manages checksums for generated data.
type ChecksumGenerator struct {
	hasher       hash.Hash
	chunkHashers map[int64]hash.Hash
	outputPath   string
	mu           sync.Mutex
	totalSize    int64
	algorithm    string
}

// ChunkInfo holds information about a chunk's checksum.
type ChunkInfo struct {
	Offset   int64
	Size     int64
	Checksum string
}

// NewChecksumGenerator creates a new checksum generator for the given output path.
func NewChecksumGenerator(outputPath string, totalSize int64) *ChecksumGenerator {
	return &ChecksumGenerator{
		hasher:       sha256.New(),
		chunkHashers: make(map[int64]hash.Hash),
		outputPath:   outputPath,
		totalSize:    totalSize,
		algorithm:    "SHA256",
	}
}

// UpdateWithChunk updates the checksum with a data chunk at the specified offset.
// This method is thread-safe and can be called concurrently from multiple goroutines.
func (c *ChecksumGenerator) UpdateWithChunk(data []byte, offset int64) error {
	if len(data) == 0 {
		return nil
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	// Validate offset
	if offset < 0 || offset >= c.totalSize {
		return fmt.Errorf("invalid offset %d for file size %d", offset, c.totalSize)
	}

	// Update the main hasher (we need to handle ordering for the main hash)
	// For now, we'll track chunks and compute the final hash when writing
	
	// Create or get chunk hasher for this offset
	if _, exists := c.chunkHashers[offset]; !exists {
		c.chunkHashers[offset] = sha256.New()
	}
	
	// Write data to the chunk hasher
	if _, err := c.chunkHashers[offset].Write(data); err != nil {
		return fmt.Errorf("failed to update chunk checksum: %v", err)
	}

	return nil
}

// GetChunkChecksums returns all chunk checksums sorted by offset.
func (c *ChecksumGenerator) GetChunkChecksums() []ChunkInfo {
	c.mu.Lock()
	defer c.mu.Unlock()

	var chunks []ChunkInfo
	for offset, hasher := range c.chunkHashers {
		checksum := hex.EncodeToString(hasher.Sum(nil))
		chunks = append(chunks, ChunkInfo{
			Offset:   offset,
			Checksum: checksum,
		})
	}

	// Sort by offset
	sort.Slice(chunks, func(i, j int) bool {
		return chunks[i].Offset < chunks[j].Offset
	})

	return chunks
}

// ComputeFileChecksum computes the checksum of the entire file by reading it.
func (c *ChecksumGenerator) ComputeFileChecksum() (string, error) {
	file, err := os.Open(c.outputPath)
	if err != nil {
		return "", fmt.Errorf("failed to open file for checksum: %v", err)
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", fmt.Errorf("failed to read file for checksum: %v", err)
	}

	return hex.EncodeToString(hasher.Sum(nil)), nil
}

// WriteChecksumFile writes the checksum information to a .checksum.txt file.
func (c *ChecksumGenerator) WriteChecksumFile() error {
	// Compute the full file checksum
	fullChecksum, err := c.ComputeFileChecksum()
	if err != nil {
		return err
	}

	checksumPath := c.outputPath + ".checksum.txt"
	file, err := os.Create(checksumPath)
	if err != nil {
		return fmt.Errorf("failed to create checksum file: %v", err)
	}
	defer file.Close()

	// Write header
	if _, err := fmt.Fprintf(file, "# Checksum file for %s\n", c.outputPath); err != nil {
		return err
	}
	if _, err := fmt.Fprintf(file, "# Generated by trasher\n\n"); err != nil {
		return err
	}

	// Write the main file checksum
	if _, err := fmt.Fprintf(file, "%s (full file): %s\n", c.algorithm, fullChecksum); err != nil {
		return err
	}

	// Write chunk checksums in order of offset
	chunks := c.GetChunkChecksums()
	if len(chunks) > 0 {
		if _, err := fmt.Fprintf(file, "\n# Chunk checksums:\n"); err != nil {
			return err
		}
		
		for _, chunk := range chunks {
			if _, err := fmt.Fprintf(file, "%s (offset %d): %s\n", 
				c.algorithm, chunk.Offset, chunk.Checksum); err != nil {
				return err
			}
		}
	}

	return nil
}

// Verify validates a file against its checksum file.
func (c *ChecksumGenerator) Verify(filePath string) (*VerificationResult, error) {
	result := &VerificationResult{
		FilePath:     filePath,
		ChecksumPath: filePath + ".checksum.txt",
	}

	// Check if file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		result.Valid = false
		result.Error = fmt.Sprintf("file does not exist: %s", filePath)
		return result, nil
	}

	// Check if checksum file exists
	if _, err := os.Stat(result.ChecksumPath); os.IsNotExist(err) {
		result.Valid = false
		result.Error = fmt.Sprintf("checksum file does not exist: %s", result.ChecksumPath)
		return result, nil
	}

	// Parse the checksum file
	expectedChecksum, err := c.parseChecksumFile(result.ChecksumPath)
	if err != nil {
		result.Valid = false
		result.Error = fmt.Sprintf("failed to parse checksum file: %v", err)
		return result, nil
	}

	// Calculate the actual file checksum
	file, err := os.Open(filePath)
	if err != nil {
		result.Valid = false
		result.Error = fmt.Sprintf("failed to open file for verification: %v", err)
		return result, nil
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		result.Valid = false
		result.Error = fmt.Sprintf("failed to read file for verification: %v", err)
		return result, nil
	}

	actualChecksum := hex.EncodeToString(hasher.Sum(nil))

	// Compare checksums
	result.Valid = (actualChecksum == expectedChecksum)
	result.ExpectedChecksum = expectedChecksum
	result.ActualChecksum = actualChecksum

	if !result.Valid {
		result.Error = "checksum mismatch"
	}

	return result, nil
}

// parseChecksumFile parses a checksum file and returns the full file checksum.
func (c *ChecksumGenerator) parseChecksumFile(checksumPath string) (string, error) {
	file, err := os.Open(checksumPath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		
		// Skip comments and empty lines
		if strings.HasPrefix(line, "#") || line == "" {
			continue
		}

		// Look for the full file checksum line
		if strings.Contains(line, "(full file)") {
			parts := strings.SplitN(line, ": ", 2)
			if len(parts) == 2 {
				return strings.TrimSpace(parts[1]), nil
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return "", err
	}

	return "", fmt.Errorf("no full file checksum found in checksum file")
}

// VerificationResult holds the result of a file verification operation.
type VerificationResult struct {
	FilePath         string
	ChecksumPath     string
	Valid            bool
	ExpectedChecksum string
	ActualChecksum   string
	Error            string
}

// String returns a human-readable string representation of the verification result.
func (r *VerificationResult) String() string {
	if r.Valid {
		return fmt.Sprintf("✓ %s: checksum verified", r.FilePath)
	} else {
		return fmt.Sprintf("✗ %s: %s", r.FilePath, r.Error)
	}
}

// VerifyFile is a convenience function to verify a file using a new ChecksumGenerator.
func VerifyFile(filePath string) (*VerificationResult, error) {
	generator := &ChecksumGenerator{
		algorithm: "SHA256",
	}
	return generator.Verify(filePath)
}

// GetAlgorithm returns the hash algorithm being used.
func (c *ChecksumGenerator) GetAlgorithm() string {
	return c.algorithm
}

// Reset clears all stored checksums and resets the generator.
func (c *ChecksumGenerator) Reset() {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.hasher.Reset()
	c.chunkHashers = make(map[int64]hash.Hash)
}