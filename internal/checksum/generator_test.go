package checksum

import (
	"os"
	"path/filepath"
	"sync"
	"testing"
)

func TestNewChecksumGenerator(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	generator := NewChecksumGenerator(testFile, 1024)
	
	if generator.outputPath != testFile {
		t.Errorf("expected output path %s, got %s", testFile, generator.outputPath)
	}
	if generator.totalSize != 1024 {
		t.Errorf("expected total size 1024, got %d", generator.totalSize)
	}
	if generator.algorithm != "SHA256" {
		t.Errorf("expected algorithm SHA256, got %s", generator.algorithm)
	}
	if generator.chunkHashers == nil {
		t.Error("chunk hashers map should be initialized")
	}
}

func TestUpdateWithChunk(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	generator := NewChecksumGenerator(testFile, 1024)
	
	// Test valid chunk update
	data := []byte("hello world")
	err := generator.UpdateWithChunk(data, 0)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	
	// Test another chunk at different offset
	data2 := []byte("test data")
	err = generator.UpdateWithChunk(data2, 100)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	
	// Verify chunks were recorded
	chunks := generator.GetChunkChecksums()
	if len(chunks) != 2 {
		t.Errorf("expected 2 chunks, got %d", len(chunks))
	}
	
	// Test invalid offset
	err = generator.UpdateWithChunk(data, -1)
	if err == nil {
		t.Error("expected error for negative offset")
	}
	
	err = generator.UpdateWithChunk(data, 1024)
	if err == nil {
		t.Error("expected error for offset >= total size")
	}
	
	// Test empty data (should not error)
	err = generator.UpdateWithChunk([]byte{}, 50)
	if err != nil {
		t.Errorf("unexpected error for empty data: %v", err)
	}
}

func TestGetChunkChecksums(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	generator := NewChecksumGenerator(testFile, 1024)
	
	// Add chunks in non-sequential order
	generator.UpdateWithChunk([]byte("chunk3"), 200)
	generator.UpdateWithChunk([]byte("chunk1"), 0)
	generator.UpdateWithChunk([]byte("chunk2"), 100)
	
	chunks := generator.GetChunkChecksums()
	
	if len(chunks) != 3 {
		t.Errorf("expected 3 chunks, got %d", len(chunks))
	}
	
	// Verify chunks are sorted by offset
	expectedOffsets := []int64{0, 100, 200}
	for i, chunk := range chunks {
		if chunk.Offset != expectedOffsets[i] {
			t.Errorf("chunk %d: expected offset %d, got %d", i, expectedOffsets[i], chunk.Offset)
		}
		if chunk.Checksum == "" {
			t.Errorf("chunk %d: checksum should not be empty", i)
		}
	}
}

func TestWriteAndVerifyChecksumFile(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	// Create a test file with known content
	testData := []byte("This is test data for checksum verification.")
	err := os.WriteFile(testFile, testData, 0644)
	if err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}
	
	generator := NewChecksumGenerator(testFile, int64(len(testData)))
	
	// Add some chunks
	generator.UpdateWithChunk(testData[:20], 0)
	generator.UpdateWithChunk(testData[20:], 20)
	
	// Write checksum file
	err = generator.WriteChecksumFile()
	if err != nil {
		t.Fatalf("failed to write checksum file: %v", err)
	}
	
	// Verify checksum file exists
	checksumPath := testFile + ".checksum.txt"
	if _, err := os.Stat(checksumPath); os.IsNotExist(err) {
		t.Error("checksum file was not created")
	}
	
	// Read and verify checksum file content
	content, err := os.ReadFile(checksumPath)
	if err != nil {
		t.Fatalf("failed to read checksum file: %v", err)
	}
	
	contentStr := string(content)
	if !containsString(contentStr, "SHA256 (full file):") {
		t.Error("checksum file should contain full file checksum")
	}
	if !containsString(contentStr, "SHA256 (offset 0):") {
		t.Error("checksum file should contain chunk checksums")
	}
	if !containsString(contentStr, "# Generated by trasher") {
		t.Error("checksum file should contain generator comment")
	}
}

func TestVerifyValidFile(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	// Create a test file
	testData := []byte("Test data for verification")
	err := os.WriteFile(testFile, testData, 0644)
	if err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}
	
	// Generate checksum file
	generator := NewChecksumGenerator(testFile, int64(len(testData)))
	generator.UpdateWithChunk(testData, 0)
	err = generator.WriteChecksumFile()
	if err != nil {
		t.Fatalf("failed to write checksum file: %v", err)
	}
	
	// Verify the file
	result, err := generator.Verify(testFile)
	if err != nil {
		t.Fatalf("verification failed with error: %v", err)
	}
	
	if !result.Valid {
		t.Errorf("verification should be valid, got: %s", result.Error)
	}
	if result.ExpectedChecksum == "" {
		t.Error("expected checksum should not be empty")
	}
	if result.ActualChecksum == "" {
		t.Error("actual checksum should not be empty")
	}
	if result.ExpectedChecksum != result.ActualChecksum {
		t.Error("expected and actual checksums should match")
	}
}

func TestVerifyInvalidFile(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	// Create original test file
	originalData := []byte("Original data")
	err := os.WriteFile(testFile, originalData, 0644)
	if err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}
	
	// Generate checksum file
	generator := NewChecksumGenerator(testFile, int64(len(originalData)))
	generator.UpdateWithChunk(originalData, 0)
	err = generator.WriteChecksumFile()
	if err != nil {
		t.Fatalf("failed to write checksum file: %v", err)
	}
	
	// Modify the file content
	modifiedData := []byte("Modified data")
	err = os.WriteFile(testFile, modifiedData, 0644)
	if err != nil {
		t.Fatalf("failed to modify test file: %v", err)
	}
	
	// Verify the modified file
	result, err := generator.Verify(testFile)
	if err != nil {
		t.Fatalf("verification failed with error: %v", err)
	}
	
	if result.Valid {
		t.Error("verification should be invalid for modified file")
	}
	if result.Error != "checksum mismatch" {
		t.Errorf("expected 'checksum mismatch' error, got: %s", result.Error)
	}
	if result.ExpectedChecksum == result.ActualChecksum {
		t.Error("expected and actual checksums should be different")
	}
}

func TestVerifyMissingFile(t *testing.T) {
	tempDir := t.TempDir()
	nonExistentFile := filepath.Join(tempDir, "nonexistent.bin")
	
	generator := NewChecksumGenerator(nonExistentFile, 1024)
	result, err := generator.Verify(nonExistentFile)
	if err != nil {
		t.Fatalf("verification failed with error: %v", err)
	}
	
	if result.Valid {
		t.Error("verification should be invalid for missing file")
	}
	if !containsString(result.Error, "does not exist") {
		t.Errorf("expected 'does not exist' error, got: %s", result.Error)
	}
}

func TestVerifyMissingChecksumFile(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	// Create test file without checksum file
	testData := []byte("Test data")
	err := os.WriteFile(testFile, testData, 0644)
	if err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}
	
	generator := NewChecksumGenerator(testFile, int64(len(testData)))
	result, err := generator.Verify(testFile)
	if err != nil {
		t.Fatalf("verification failed with error: %v", err)
	}
	
	if result.Valid {
		t.Error("verification should be invalid for missing checksum file")
	}
	if !containsString(result.Error, "checksum file does not exist") {
		t.Errorf("expected 'checksum file does not exist' error, got: %s", result.Error)
	}
}

func TestVerifyFileConvenienceFunction(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	// Create test file and checksum
	testData := []byte("Convenience function test")
	err := os.WriteFile(testFile, testData, 0644)
	if err != nil {
		t.Fatalf("failed to create test file: %v", err)
	}
	
	generator := NewChecksumGenerator(testFile, int64(len(testData)))
	generator.UpdateWithChunk(testData, 0)
	err = generator.WriteChecksumFile()
	if err != nil {
		t.Fatalf("failed to write checksum file: %v", err)
	}
	
	// Test convenience function
	result, err := VerifyFile(testFile)
	if err != nil {
		t.Fatalf("VerifyFile failed: %v", err)
	}
	
	if !result.Valid {
		t.Errorf("VerifyFile should return valid result, got: %s", result.Error)
	}
}

func TestConcurrentChunkUpdates(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	generator := NewChecksumGenerator(testFile, 10000)
	
	var wg sync.WaitGroup
	numWorkers := 10
	
	// Update chunks concurrently
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			
			offset := int64(workerID * 100)
			data := make([]byte, 50)
			for j := range data {
				data[j] = byte(workerID)
			}
			
			err := generator.UpdateWithChunk(data, offset)
			if err != nil {
				t.Errorf("worker %d failed to update chunk: %v", workerID, err)
			}
		}(i)
	}
	
	wg.Wait()
	
	// Verify all chunks were recorded
	chunks := generator.GetChunkChecksums()
	if len(chunks) != numWorkers {
		t.Errorf("expected %d chunks, got %d", numWorkers, len(chunks))
	}
	
	// Verify chunks are properly sorted
	for i := 1; i < len(chunks); i++ {
		if chunks[i].Offset <= chunks[i-1].Offset {
			t.Error("chunks should be sorted by offset")
			break
		}
	}
}

func TestReset(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	generator := NewChecksumGenerator(testFile, 1024)
	
	// Add some chunks
	generator.UpdateWithChunk([]byte("data1"), 0)
	generator.UpdateWithChunk([]byte("data2"), 100)
	
	// Verify chunks exist
	chunks := generator.GetChunkChecksums()
	if len(chunks) != 2 {
		t.Errorf("expected 2 chunks before reset, got %d", len(chunks))
	}
	
	// Reset
	generator.Reset()
	
	// Verify chunks are cleared
	chunks = generator.GetChunkChecksums()
	if len(chunks) != 0 {
		t.Errorf("expected 0 chunks after reset, got %d", len(chunks))
	}
}

func TestVerificationResultString(t *testing.T) {
	// Test valid result
	validResult := &VerificationResult{
		FilePath: "/path/to/file.bin",
		Valid:    true,
	}
	resultStr := validResult.String()
	if !containsString(resultStr, "✓") || !containsString(resultStr, "verified") {
		t.Errorf("valid result string should contain checkmark and 'verified': %s", resultStr)
	}
	
	// Test invalid result
	invalidResult := &VerificationResult{
		FilePath: "/path/to/file.bin",
		Valid:    false,
		Error:    "checksum mismatch",
	}
	resultStr = invalidResult.String()
	if !containsString(resultStr, "✗") || !containsString(resultStr, "checksum mismatch") {
		t.Errorf("invalid result string should contain X and error: %s", resultStr)
	}
}

func TestGetAlgorithm(t *testing.T) {
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.bin")
	
	generator := NewChecksumGenerator(testFile, 1024)
	
	if generator.GetAlgorithm() != "SHA256" {
		t.Errorf("expected algorithm SHA256, got %s", generator.GetAlgorithm())
	}
}

// Helper function to check if a string contains a substring
func containsString(s, substr string) bool {
	return len(s) >= len(substr) && 
		   (s == substr || len(s) > len(substr) && 
		   (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || 
		   containsSubstring(s, substr)))
}

func containsSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// Benchmark tests
func BenchmarkUpdateWithChunk(b *testing.B) {
	tempDir := b.TempDir()
	testFile := filepath.Join(tempDir, "bench.bin")
	
	generator := NewChecksumGenerator(testFile, int64(b.N*1024))
	data := make([]byte, 1024)
	for i := range data {
		data[i] = byte(i % 256)
	}
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		offset := int64(i * 1024)
		generator.UpdateWithChunk(data, offset)
	}
}

func BenchmarkGetChunkChecksums(b *testing.B) {
	tempDir := b.TempDir()
	testFile := filepath.Join(tempDir, "bench.bin")
	
	generator := NewChecksumGenerator(testFile, 10000)
	data := []byte("benchmark data")
	
	// Add some chunks
	for i := 0; i < 100; i++ {
		generator.UpdateWithChunk(data, int64(i*100))
	}
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		generator.GetChunkChecksums()
	}
}